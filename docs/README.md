# 🚀 기능명세서

## 입력 / 출력

- [x] 메시지를 주입받아 렌더링하고 입력받은 값을 반환한다.
- [x] 입력받은 값에 대해 공통적인 예외처리를 진행한다.

## ~~Player~~ => BaseballNumber

- [x] 세 개의 숫자를 갖는다.
- [x] 숫자를 외부에서 주입받는다.

  - 생성자의 값에 대한 유연성(string, Array, number) 제공하기. 다만, 안정성을 확보할 것.

    - [x] number 처리 => string 처리 => 배열처리 => 예외처리 순으로 진행한다.
    - [x] 커스텀 에러를 사용한다.

  - [x] 숫자가 유효한지 확인한다.
  - [x] baseballNumber 관련 validation 유틸함수는 전부 제거하고 메서드는 private field로 유지한다.

- [x] 숫자는 private field로 관리한다.
- [x] 컴퓨터는 해당 필드를 DI받아 사용한다.
- [x] 커스텀 에러를 추가한다.

## 컴퓨터

- [x] 정답이 되는 BaseballNumber를 갖는다.

  - [x] 숫자는 랜덤하게 결정된다.
    - [x] 유효 숫자인지 검증한다.
    - [x] 난수 추출은 주어진 유틸함수를 사용한다.

- [x] 숫자를 비교하는 메서드를 제공한다.
  - [x] 유효성 검사를 진행한다.
    - [x] 생성자에서 사용한 validation을 재사용한다.

## 유저

- [x] 세 개의 숫자를 갖는다.
  - [x] 숫자는 유저에게 입력받는다.
    - [x] 유효 숫자인지 검증한다.

## 게임

### consturctor

- [x] 게임을 시작한다.
  - [x] 시작 메시지를 렌더링한다.

### initial

- [x] 게임 환경을 초기화한다.
  - [x] 컴퓨터에게 숫자를 셋팅한다.

### guess

- [x] 유저에게 숫자를 입력받는다.
  - [x] 숫자가 유효한지 확인하고, 유저에게 할당한다.
    - [x] 1-9 사이의 숫자이다.
    - [x] 숫자는 중복되지 않는다.
  - [x] 유저의 숫자와 컴퓨터의 숫자를 비교한다.
    - [x] 두 번호를 주입받는다.
    - [x] 유효한 숫자인지 확인한다.
      - [x] 두 번호의 자릿수를 비교한다.
      - [x] 각 자리가 숫자인지 확인한다.
      - [x] 중복되는 숫자가 있는지 확인한다.
  - [x] 결과를 출력한다.
  - [x] 세 개의 숫자를 맞추지 못할 경우 다시 숫자를 입력받는다.
- [x] 세 개의 숫자를 맞출 경우 게임을 다시 시작할지 물어본다.

## 예외처리

- [x] 사용자가 잘못된 값을 입력한 경우 throw문을 사용해 예외를 발생시킨후 애플리케이션은 종료되어야 한다.

- [x] 모든 에러 메시지는 `[ERROR]`로 시작한다.

  - [x] 커스텀 에러를 생성하여 메시지를 통일한다.

- [x] 숫자에 0을 입력할 경우, "숫자가 아닙니다"라고 처리되는 부분 처리하기.
- [x] 엣지케이스 더 찾아보고 추가(e와 같은 경우)

## 테스트

- [x] 각 도메인별로 유의미한 테스트를 작성한다
  - [x] BaseballNumber
  - [x] Computer
  - [x] BaseballGame => 앗.. Computer 객체랑 일이 똑같네. 테스트 동일함.

---

## 리팩터링 사항

객관적으로 다시 한 번 살펴보기

### constants

- [x] baseballGame
  - 음... 변수를 받아서 string을 반환하는게 상수인가? 고민해보기.
    => 아 유틸함수로 빼면 되겠구나!
    - [x] 상수 내 메서드 유틸함수로 분리
- [x] error
      => 음 뭔가 에러메시지 많아지면 도메인별로 나누는게 확장성 좋을듯. 다만, 지금은 에러메시지 많지 않으니 일단 유지하기.
- [x] message
- [x] type => 흠 뭔가 과도한 파일 분리같은데. 굳이 소프트코딩을 적용했어야 했나? 타입 분리가 엄청 크리티컬하진 않지만, 과도한 파일분리로 볼 수 있을듯. BaseballNumber 파일 내부 하단으로 옮기기!
  - [x] 분리하다보니, 그냥 파일 이름을 잘못정해서 도메인이 애매하게 분리됨. answerGenerator => baseballNubmerUtils 변경

### Model

- [x] BaseballNumber
- [x] Computer
- [x] Error

### utils

- [x] baseballNumberUtils
- [x] messageUtils

### View

- [x] InputView
- [x] View

### Root

- [x] App.js
      흠.. 이 부분은 재귀 => while문으로 바꾸는 것도 나쁜 선택은 아니었지만, 지금 보니까 App 내부에 Baseball 도메인 관련 메서드를 최소화했으면 더 좋지 않았을까? 싶기도 함. input받는 메서드를 DI 후, baseball에서 사용했어도 그렇게 큰 의존성은 아니지 않을까? 숫자 검증도 BaseballNumber 사용해도 괜찮으니..! 더 고민해보기.

- [x] BaseballGame

### CustomError

Why? : 각 객체들은 들어오는 값에 대한 검증을 진행하여 애플리케이션의 안정도를 확보한다.
단순히 에러를 던지기만하면 객체의 관계가 복잡해질수록 어떤 친구가 던진 에러인지 추적하기 어려워진다. (특히 Computer, Player쪽이 상속받다보니 더 어려웠음.)

- [x] 각 객체는 자신이 던지는 ERROR를 직접 커스텀 에러로 추상화하여 사용한다.(name: 객체 본인의 이름으로)

### View

- Why? : View가 생각보다 무거워지고 있다. 순수 print / read와 View의 추상화 계층을 분리한다.

  - Input : InputView는 한 단계 검증이 필요하기에 추상화하여 공통 검증을 진행한다.

    - [x] 빈 문자열을 확인한다.
    - [x] 커스텀 에러를 추가한다.

  - Output : print는 검증할 값이 없기에 추상화하지 않는다. View 객체 내부에서 직접 Console 유틸함수를 추상화하여 사용한다.

- [x] View의 메서드는 InputView의 메서드와 Console.print 메서드를 사용하여 직접 추상화한다. 컨트롤러에서 굳이 상수 import해서 복잡하게 관리하는거보단 View 단에서 직접 추상화하고 메서드 호출만 하는게 가장 깔끔한듯?
