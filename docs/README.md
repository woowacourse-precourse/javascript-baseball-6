## 🚀 기능 구현 목록

### 1. 기능을 세가지로 구분해 구현한다. (출력, 입력 처리, 비교 연산)
#### 🥕 출력
```
  1. 게임 시작 출력
    a. 게임 시작 시 - "숫자 야구 게임을 시작합니다."
  2. 유저 입력 받을 시 안내 문구 출력
    a. 입력 대기 시 - "숫자를 입력해주세요 : "
  3. 유저 입력별 숫자 비교 결과 출력
    a. 스트라이크만 있는 경우 - "N스트라이크"
    b. 스트라이크와 볼이 같이 존재하는 경우 - "N볼 N스트라이크"
    c. 스트라이크와 볼이 없는 경우 - "낫싱"
    d. 3스트라이크 - "3스트라이크\n3개의 숫자를 모두 맞히셨습니다! 게임 종료"
  4. 게임 재시작 여부 출력
    a. 재시작 여부 안내 시 - "게임을 새로 시작하려면 1, 종료하려면 2를 입력하세요."
    b. 재시작 시 - (1-a)출력
    c. 종료 시 - 출력 없음.
    d. 입력 값 유효하지 않을 시 - "게임을 새로 시작하려면 1, 종료하려면 2를 입력하세요."
```
#### 🥕 입력 처리
```
  1. COM(상대)의 입력을 생성한다.
    a. 중복되지 않는 랜덤 숫자를 3개 생성한다.
  2. 유저 입력을 구분한다.
    a. 입력을 숫자로 변환한다.
    b. 자리수 별 숫자가 유저 입력에서 유일한지 확인한다.
      i. 유일하지 않다면 에러를 던진다.
  3. 재시작 입력 여부 입력 받기
```
#### 🥕 비교 연산
```
  1. 스트라이크 체크
    a. COM 생성 난수와 유저 입력의 같은 인덱스의 값을 비교한다.
      i. 일치 시 스트라이크 증가
    b. a 불일치 시, 유저 입력이 COM 생성 난수에 포함되는 값인지 비교한다.
      i. 포함될 시 볼 증가
  2. 재시작 입력 유효성 체크
    a. 재시작 입력이 1 혹은 2인지 체크한다.
      i. 1 혹은 2가 아닐 경우 다시 입력 받는다.
```
### 2. 사용할 메세지와 상수를 정의한다.
#### 🥕 사용할 메세지와 상수
```
  유저 입력 메세지 - '숫자를 입력해주세요 : ';
  게임 시작 메세지 - '숫자 야구 게임을 시작합니다.';
  에러 발생 메세지 - '[ERROR] 유효하지 않은 입력입니다.';
  게임 재시작 메세지 - '게임을 새로 시작하려면 1, 종료하려면 2를 입력하세요.';
  문자와 인덱스가 모두 포함되지 않을 경우 메세지 - '낫싱';
  인덱스가 일치하는 문자의 경우 메세지 - '스트라이크';
  문자가 포함될 경우 메세지 - '볼';
  게임 종료 메세지 - '3스트라이크\n3개의 숫자를 모두 맞히셨습니다! 게임 종료';
  게임 재시작 입력값 상수 - '1';
  게임 종료 입력값 상수 - '2';
  입력 문자 최솟값 - '1';
  입력 문자 최댓값 - '9';
```
### 3. paly 함수를 구현한다.
#### 🥕 위 구현 사항 외 기능 추가
```
  1. 재시작 시 랜덤 숫자 재생성 반복문
  2. 재시작 입력이 종료일 경우 게임 정상 종료
```
---
## TIL (공부해야할 부분 && 알게된 부분)

#### 1. 코드 컨벤션을 공부하며 알게된 점.

JS는 인터프리터 언어이기에 컴파일 과정 없이 바로 실행한다.

const(상수)를 기본적으로 사용하며 재할당이 필요한 경우 let을 사용하는 이유
- `var`은 재선언, 재할당이 가능한 함수레벨 스코프로 if 문, for 문 등의 블록 내에서 선언되더라도 외부에서 접근이 가능할 수 있다.
- 반면, let은 재할당 가능, 재선언과 호이스팅 불가 / const는 재선언, 재할당, 호이스팅 모두 불가
- `var`는 호이스팅될 때 변수를 `undefined`로 초기화하지만, `let`과 `const`는 Refference Error.
- 따라서, `let`과 `const`는 사용 전 선언이 필수 (가독, 유지보수 유리)

airbnb 코드 컨벤션에 따라 사용 가능한 상황에서 화살표 함수를 const 변수로 사용했고, 
우테코 컨벤션에 따라 const 변수를 모두 대문자 snake 형식으로 사용했다.

```js
//Compare.js
export const IS_VALID_INPUT = (INPUT) => {
    if (!INPUT) return false;
    const NUMBER_SET = new Set(INPUT);
  
    return (
      INPUT.length === 3 &&
      NUMBER_SET.size === 3 &&
      [...NUMBER_SET].every((num) => num >= DIGIT_MIN && num <= DIGIT_MAX)
    );
};

export const COMPARE_NUMBER = (PLAYER, COMPUTER) => {
  let strikes = 0;
  let balls = 0;

  PLAYER.forEach((digitOfPlayer, idx) => {
    if (digitOfPlayer === COMPUTER[idx]) {
      strikes += 1;
    } else if (COMPUTER.includes(digitOfPlayer)) {
      balls += 1;
    }
  });

  return { strikes, balls };
};
```

### 2. App 클래스와 기능별 함수 구현 파일 분리

개인적으로 확장성을 생각해서 `ex) 9회 야구 룰을 적용한 사용자와 컴퓨터 간 숫자 야구`
클래스 내부에 로직에 큰 flow의 게임 흐름만 놔두고 싶었기에 함수를 모듈화하여 각 기능 구분 별로 파일로 만들었다.
이 부분에 고민이 많았는데 큰 흐름의 로직을 play 메서드에서 모듈화하지 않은 이유는 App 클래스만을 보고 한 눈에 흐름을 파악하고 싶었다.
class를 extends 하는 방법으로 확장을 생각했지만 예시처럼 구체적으로 규모가 큰 게임이 될 경우 현재의 기능의 로직을 50% 이상 재구현해야할 가능성이 높기 때문에 함수를 import 하고 재조립하는 방식이 더 편할 것이라고 생각했다. 
(서브젝트의 내용이 확장성을 생각하라고 하지도 않았고 확장의 규모 또한 정해지지 않았기 때문에 순전히 개인적인 생각이다.)

### 3. 함수명과 변수명에 의미 담기
네이밍 컨벤션을 우테코에서 새로운 가이드를 주었기 때문에 먼저 그 부분을 준수해서 작성한 후
에어비엔비 코드 컨벤션의 네이밍 컨벤션을 덮어씌우는 방식으로 생각해서 수정하였다.

`변수나 함수 이름에는 접두사나 접미사로 타입 정보를 넣지 않아야 합니다.`

이 부분을 지키지 못한 부분을 대거 수정했다.
또한, 함수 및 변수를 외부에 선언하고 호출했기 때문에 `App.js`만을 보고도 흐름을 읽는데에 불편함이 없도록 최대한 함수명에 기능이 이해가도록 작성했다.

### 4. 컨벤션 의문사항 (?)
multiple한 import 시 각 모듈에 대해 개행과 마지막 가져오기에 `,`를 붙이는 부분이 지금까지는 보지 못했던 부분이라 신기하고 설명 또한 `Why? Having multiple lines that import from the same path can make code harder to maintain.`이 전부라서 `,`를 붙이는 이유에 대해선 명쾌한 설명이 되지 않아 궁금했다.
보통 객체의 속성에 이런 방식을 채택하는 것으로 아는데 import에 이런 패턴을 처음봐서 생소한 것일 수도 있겠다.

또한 import 시 확장자를 미포함하는지 궁금했는데,

요약하자면 불필요한 세부 사항 노출, 하드 코딩이며 리팩토링이 불가능한 구조로 작성하는 것이기 때문이라는 것을 알게 되었다.

```js
import { 
    COMPARE_NUMBER,
    IS_VALID_INPUT,
} from './Compare';
import { 
    PRINT_ERROR_MESSAGE,
    PRINT_START_MESSAGE,
    PRINT_RESULT_MESSAGE,
} from './Output';
import { 
    EXIT_GAME,
    LINE_INPUT_MESSAGE,
    RESTART_GAME,
    RESTART_MESSAGE,
} from './Define';
```
